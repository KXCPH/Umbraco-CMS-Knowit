using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Umbraco.Cms.Infrastructure.ModelsBuilder.Building.Interfaces;

namespace Umbraco.Cms.Infrastructure.ModelsBuilder.Building
{
    public class TextBuilderActions : ITextBuilderActions
    {
        private readonly IBuilderBase _builderBase;
        private readonly ITextBuilderSubActions _textBuilderSubActions;
        public TextBuilderActions(IBuilderBase builderBase, ITextBuilderSubActions textBuilderSubActions)
        {
            _builderBase = builderBase;
            _textBuilderSubActions = textBuilderSubActions;
        }
        public void WriteHeader(StringBuilder sb)
        {
            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("// <auto-generated>\n");
            sb.Append("//   This code was generated by a tool.\n");
            sb.Append("//\n");
            sb.AppendFormat("//    Umbraco.ModelsBuilder.Embedded v{0}\n", ApiVersion.Current.Version);
            sb.Append("//\n");
            sb.Append("//   Changes to this file will be lost if the code is regenerated.\n");
            sb.Append("// </auto-generated>\n");
            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("\n");
        }
        public void WriteUsing(StringBuilder sb, IEnumerable<string> typeUsing)
        {
            foreach (var t in typeUsing)
            {
                sb.AppendFormat("using {0};\n", t);
            }
        }

        public void WriteNamespace(StringBuilder sb, string modelNamespace)
        {
            sb.Append("\n");
            sb.AppendFormat("namespace {0}\n", modelNamespace);
            sb.Append("{\n");
        }
        public void WriteContentType(StringBuilder sb, TypeModel type, bool lineBreak)
        {
            string sep;
            if (type.IsMixin)
            {
                // write the interface declaration
                sb.AppendFormat("\t// Mixin Content Type with alias \"{0}\"\n", type.Alias);
                if (!string.IsNullOrWhiteSpace(type.Name))
                {
                    sb.AppendFormat("\t/// <summary>{0}</summary>\n", _textBuilderSubActions.XmlCommentString(type.Name));
                }

                sb.AppendFormat("\tpublic partial interface I{0}", type.ClrName);
                var implements = type.BaseType == null
                    ? type.HasBase ? null : type.IsElement ? "PublishedElement" : "PublishedContent"
                    : type.BaseType.ClrName;
                if (implements != null)
                {
                    sb.AppendFormat(" : I{0}", implements);
                }

                // write the mixins
                sep = implements == null ? ":" : ",";
                foreach (TypeModel mixinType in type.DeclaringInterfaces.OrderBy(x => x.ClrName))
                {
                    sb.AppendFormat("{0} I{1}", sep, mixinType.ClrName);
                    sep = ",";
                }

                sb.Append("\n\t{\n");

                // write the properties - only the local (non-ignored) ones, we're an interface
                var more = false;
                foreach (PropertyModel prop in type.Properties.OrderBy(x => x.ClrName))
                {
                    if (more)
                    {
                        sb.Append("\n");
                    }

                    more = true;
                    _textBuilderSubActions.WriteInterfaceProperty(sb, prop);
                }

                sb.Append("\t}\n\n");
            }

            // write the class declaration
            if (!string.IsNullOrWhiteSpace(type.Name))
            {
                sb.AppendFormat("\t/// <summary>{0}</summary>\n", _textBuilderSubActions.XmlCommentString(type.Name));
            }

            // cannot do it now. see note in ImplementContentTypeAttribute
            // if (!type.HasImplement)
            //    sb.AppendFormat("\t[ImplementContentType(\"{0}\")]\n", type.Alias);
            sb.AppendFormat("\t[PublishedModel(\"{0}\")]\n", type.Alias);
            sb.AppendFormat("\tpublic partial class {0}", type.ClrName);
            var inherits = type.HasBase
                ? null // has its own base already
                : type.BaseType == null
                    ? _builderBase.GetModelsBaseClassName(type)
                    : type.BaseType.ClrName;
            if (inherits != null)
            {
                sb.AppendFormat(" : {0}", inherits);
            }

            sep = inherits == null ? ":" : ",";
            if (type.IsMixin)
            {
                // if it's a mixin it implements its own interface
                sb.AppendFormat("{0} I{1}", sep, type.ClrName);
            }
            else
            {
                // write the mixins, if any, as interfaces
                // only if not a mixin because otherwise the interface already has them already
                foreach (TypeModel mixinType in type.DeclaringInterfaces.OrderBy(x => x.ClrName))
                {
                    sb.AppendFormat("{0} I{1}", sep, mixinType.ClrName);
                    sep = ",";
                }
            }

            // begin class body
            sb.Append("\n\t{\n");

            // write the constants & static methods
            // as 'new' since parent has its own - or maybe not - disable warning
            sb.Append("\t\t// helpers\n");
            sb.Append("#pragma warning disable 0109 // new is redundant\n");
            _textBuilderSubActions.WriteGeneratedCodeAttribute(sb, "\t\t");
            sb.AppendFormat(
                "\t\tpublic new const string ModelTypeAlias = \"{0}\";\n",
                type.Alias);
            TypeModel.ItemTypes itemType = type.IsElement ? TypeModel.ItemTypes.Content : type.ItemType; // TODO
            _textBuilderSubActions.WriteGeneratedCodeAttribute(sb, "\t\t");
            sb.AppendFormat(
                "\t\tpublic new const PublishedItemType ModelItemType = PublishedItemType.{0};\n",
                itemType);
            _textBuilderSubActions.WriteGeneratedCodeAttribute(sb, "\t\t");
            _textBuilderSubActions.WriteMaybeNullAttribute(sb, "\t\t", true);
            sb.Append(
                "\t\tpublic new static IPublishedContentType GetModelContentType(IPublishedSnapshotAccessor publishedSnapshotAccessor)\n");
            sb.Append(
                "\t\t\t=> PublishedModelUtility.GetModelContentType(publishedSnapshotAccessor, ModelItemType, ModelTypeAlias);\n");
            _textBuilderSubActions.WriteGeneratedCodeAttribute(sb, "\t\t");
            _textBuilderSubActions.WriteMaybeNullAttribute(sb, "\t\t", true);
            sb.AppendFormat(
                "\t\tpublic static IPublishedPropertyType GetModelPropertyType<TValue>(IPublishedSnapshotAccessor publishedSnapshotAccessor, Expression<Func<{0}, TValue>> selector)\n",
                type.ClrName);
            sb.Append(
                "\t\t\t=> PublishedModelUtility.GetModelPropertyType(GetModelContentType(publishedSnapshotAccessor), selector);\n");
            sb.Append("#pragma warning restore 0109\n\n");
            sb.Append("\t\tprivate IPublishedValueFallback _publishedValueFallback;");

            // write the ctor
            sb.AppendFormat(
                "\n\n\t\t// ctor\n\t\tpublic {0}(IPublished{1} content, IPublishedValueFallback publishedValueFallback)\n\t\t\t: base(content, publishedValueFallback)\n\t\t{{\n\t\t\t_publishedValueFallback = publishedValueFallback;\n\t\t}}\n\n",
                type.ClrName, type.IsElement ? "Element" : "Content");

            
        }

        public void WriteContentTypeProperties(StringBuilder sb, TypeModel type)
        {
            sb.Append("\t\t// properties\n");
            var staticMixinGetters = true;

            // write the properties
            foreach (PropertyModel prop in type.Properties.OrderBy(x => x.ClrName))
            {
                _textBuilderSubActions.WriteProperty(sb, type, prop, staticMixinGetters && type.IsMixin ? type.ClrName : null);
            }

            // no need to write the parent properties since we inherit from the parent
            // and the parent defines its own properties. need to write the mixins properties
            // since the mixins are only interfaces and we have to provide an implementation.

            // write the mixins properties
            foreach (TypeModel mixinType in type.ImplementingInterfaces.OrderBy(x => x.ClrName))
            {
                foreach (PropertyModel prop in mixinType.Properties.OrderBy(x => x.ClrName))
                {
                    if (staticMixinGetters)
                    {
                        _textBuilderSubActions.WriteMixinProperty(sb, prop, mixinType.ClrName);
                    }
                    else
                    {
                        _textBuilderSubActions.WriteProperty(sb, mixinType, prop);
                    }
                }
            }

            // close the class declaration
            sb.Append("\t}\n");
        }

        public void WriteCloseClass(StringBuilder sb) => sb.Append("}\n");
        public void WriteAssemblyAttributesMarker(StringBuilder sb) => sb.Append("\n//ASSATTR\n");
    }
}
